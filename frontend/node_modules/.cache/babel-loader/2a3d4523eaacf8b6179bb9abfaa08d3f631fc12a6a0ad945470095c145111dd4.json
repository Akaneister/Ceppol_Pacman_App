{"ast":null,"code":"var _jsxFileName = \"D:\\\\Stage\\\\MarineV3\\\\frontend\\\\src\\\\components\\\\pages\\\\carte.js\",\n  _s = $RefreshSig$();\nimport { useState, useEffect, useRef } from 'react';\nimport axios from 'axios';\nimport 'leaflet/dist/leaflet.css';\nimport L from 'leaflet';\nimport '../css/carte.css';\nimport React from \"react\";\nimport Tesseract from \"tesseract.js\";\n\n// Fix Leaflet marker icon issue\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\ndelete L.Icon.Default.prototype._getIconUrl;\nL.Icon.Default.mergeOptions({\n  iconRetinaUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-icon-2x.png',\n  iconUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-icon.png',\n  shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-shadow.png'\n});\nconst Carte = () => {\n  _s();\n  const [lieux, setLieux] = useState([]);\n  const [rapportTitres, setRapportTitres] = useState({});\n  const mapRef = useRef(null);\n  const mapContainerRef = useRef(null);\n  const [pointActuel, setPointActuel] = useState(null);\n  const markerRefs = useRef([]);\n  const gifOverlayRef = useRef(null);\n  const [pendingGif, setPendingGif] = useState(null);\n\n  // Ajout pour coordonnées extraites par Tesseract\n  const [parsedCoords, setParsedCoords] = useState({\n    hautGauche: {\n      lat: '',\n      lng: ''\n    },\n    basDroite: {\n      lat: '',\n      lng: ''\n    }\n  });\n  const [isParsing, setIsParsing] = useState(false);\n  const API_BASE_URL = process.env.REACT_APP_API_URL;\n\n  // Fonction pour convertir DMS en décimal avec support de formats variés\n  function dmsToDecimal(degreesStr, minutesStr, direction) {\n    // Nettoyer les chaînes en supprimant les caractères parasites\n    const degrees = parseInt(degreesStr.replace(/[^\\d]/g, ''), 10);\n    const minutes = parseFloat(minutesStr.replace(',', '.').replace(/[^\\d.]/g, ''));\n    let decimal = degrees + minutes / 60;\n    if (direction === 'S' || direction === 'W') {\n      decimal *= -1;\n    }\n    return decimal;\n  }\n\n  // Fonction améliorée pour parser les coordonnées du quadrillage\n  const parseGifForGridCoords = async gifDataUrl => {\n    setIsParsing(true);\n    return new Promise(resolve => {\n      const img = document.createElement(\"img\");\n      img.src = gifDataUrl;\n      img.onload = async () => {\n        try {\n          // Créer un canvas pour traiter l'image\n          const canvas = document.createElement(\"canvas\");\n          canvas.width = img.width;\n          canvas.height = img.height;\n          const ctx = canvas.getContext(\"2d\");\n          ctx.drawImage(img, 0, 0);\n\n          // Préprocessing pour améliorer la reconnaissance\n          const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n          const data = imageData.data;\n\n          // Augmenter le contraste pour mieux distinguer le texte du quadrillage\n          for (let i = 0; i < data.length; i += 4) {\n            const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;\n            // Améliorer le contraste pour le texte noir sur fond clair\n            const contrast = avg < 180 ? 0 : 255;\n            data[i] = data[i + 1] = data[i + 2] = contrast;\n          }\n          ctx.putImageData(imageData, 0, 0);\n          const processedDataUrl = canvas.toDataURL(\"image/png\");\n\n          // OCR avec Tesseract avec paramètres optimisés pour les cartes\n          const {\n            data: {\n              text\n            }\n          } = await Tesseract.recognize(processedDataUrl, \"eng\", {\n            logger: m => console.log(m),\n            tessedit_char_whitelist: '0123456789°\\'\\\"NSEW-.,',\n            psm: 6 // Uniform block of text\n          });\n          console.log(\"Texte extrait:\", text);\n\n          // Patterns pour différents formats de coordonnées trouvés sur les cartes météo\n          const patterns = [\n          // Format principal: 49°54'N, 1°36'W (axes de la carte)\n          /(\\d+)°(\\d+)'([NS])/g, /(\\d+)°(\\d+)'([EW])/g,\n          // Format alternatif: 49°54N, 1°36W\n          /(\\d+)°(\\d+)([NS])/g, /(\\d+)°(\\d+)([EW])/g,\n          // Format avec minutes décimales: 49°54.0'N\n          /(\\d+)°(\\d+\\.?\\d*)'?([NS])/g, /(\\d+)°(\\d+\\.?\\d*)'?([EW])/g];\n          let latitudes = [];\n          let longitudes = [];\n\n          // Extraire toutes les coordonnées avec tous les patterns\n          patterns.forEach(pattern => {\n            let match;\n            while ((match = pattern.exec(text)) !== null) {\n              const degrees = match[1];\n              const minutes = match[2] || '0';\n              const direction = match[3];\n              const decimal = dmsToDecimal(degrees, minutes, direction);\n              if (direction === 'N' || direction === 'S') {\n                if (decimal >= -90 && decimal <= 90) {\n                  // Validation latitude\n                  latitudes.push(decimal);\n                }\n              } else if (direction === 'E' || direction === 'W') {\n                if (decimal >= -180 && decimal <= 180) {\n                  // Validation longitude\n                  longitudes.push(decimal);\n                }\n              }\n            }\n          });\n\n          // Supprimer les doublons et trier\n          latitudes = [...new Set(latitudes)].sort((a, b) => b - a); // Du plus grand au plus petit\n          longitudes = [...new Set(longitudes)].sort((a, b) => a - b); // Du plus petit au plus grand\n\n          console.log(\"Latitudes trouvées:\", latitudes);\n          console.log(\"Longitudes trouvées:\", longitudes);\n\n          // Déterminer les coins de la carte\n          let hautGauche = {\n            lat: \"\",\n            lng: \"\"\n          };\n          let basDroite = {\n            lat: \"\",\n            lng: \"\"\n          };\n          if (latitudes.length >= 2 && longitudes.length >= 2) {\n            // Prendre les extrêmes pour définir le rectangle englobant\n            const latMax = Math.max(...latitudes);\n            const latMin = Math.min(...latitudes);\n            const lngMin = Math.min(...longitudes);\n            const lngMax = Math.max(...longitudes);\n            hautGauche = {\n              lat: latMax,\n              lng: lngMin\n            };\n            basDroite = {\n              lat: latMin,\n              lng: lngMax\n            };\n          } else {\n            console.warn(\"Pas assez de coordonnées trouvées pour définir les coins\");\n          }\n          setIsParsing(false);\n          resolve({\n            hautGauche,\n            basDroite\n          });\n        } catch (error) {\n          console.error(\"Erreur lors du parsing:\", error);\n          setIsParsing(false);\n          resolve({\n            hautGauche: {\n              lat: \"\",\n              lng: \"\"\n            },\n            basDroite: {\n              lat: \"\",\n              lng: \"\"\n            }\n          });\n        }\n      };\n      img.onerror = () => {\n        console.error(\"Erreur de chargement de l'image\");\n        setIsParsing(false);\n        resolve({\n          hautGauche: {\n            lat: \"\",\n            lng: \"\"\n          },\n          basDroite: {\n            lat: \"\",\n            lng: \"\"\n          }\n        });\n      };\n    });\n  };\n\n  // Gère la sélection d'un fichier GIF par l'utilisateur\n  const handleGifUpload = async event => {\n    const file = event.target.files[0];\n    if (!file || !file.name.endsWith('.gif')) return;\n    const reader = new FileReader();\n    reader.onload = async function (e) {\n      setPendingGif(e.target.result);\n      console.log(\"Début de l'analyse du GIF...\");\n      // Appel du parser pour extraire les coordonnées du quadrillage\n      const coords = await parseGifForGridCoords(e.target.result);\n      console.log(\"Coordonnées extraites:\", coords);\n      setParsedCoords(coords);\n    };\n    reader.readAsDataURL(file);\n  };\n\n  // Valide et superpose le GIF sur la carte Leaflet en utilisant les coordonnées du quadrillage\n  const handleValidateGif = () => {\n    if (!pendingGif || !mapRef.current) return;\n    const img = new window.Image();\n    img.crossOrigin = 'anonymous';\n    img.onload = () => {\n      // Utiliser les coordonnées extraites du quadrillage\n      const hautGauche = parsedCoords.hautGauche;\n      const basDroite = parsedCoords.basDroite;\n\n      // Vérifier que les coordonnées sont valides\n      if (!hautGauche.lat || !hautGauche.lng || !basDroite.lat || !basDroite.lng) {\n        console.warn(\"Coordonnées du quadrillage non disponibles, utilisation des valeurs par défaut\");\n        // Valeurs par défaut pour la zone Bretagne/Manche\n        const bounds = [[48.5, -5.0],\n        // Sud-Ouest\n        [50.5, -1.0] // Nord-Est\n        ];\n        if (gifOverlayRef.current) {\n          mapRef.current.removeLayer(gifOverlayRef.current);\n          gifOverlayRef.current = null;\n        }\n        const overlay = L.imageOverlay(pendingGif, bounds, {\n          opacity: 0.7,\n          interactive: false\n        });\n        overlay.addTo(mapRef.current);\n        gifOverlayRef.current = overlay;\n      } else {\n        // Utiliser les coordonnées extraites du quadrillage\n        const bounds = [[parseFloat(basDroite.lat), parseFloat(hautGauche.lng)],\n        // Sud-Ouest\n        [parseFloat(hautGauche.lat), parseFloat(basDroite.lng)] // Nord-Est\n        ];\n        console.log(\"Bounds calculés:\", bounds);\n        if (gifOverlayRef.current) {\n          mapRef.current.removeLayer(gifOverlayRef.current);\n          gifOverlayRef.current = null;\n        }\n        const overlay = L.imageOverlay(pendingGif, bounds, {\n          opacity: 0.7,\n          interactive: false\n        });\n        overlay.addTo(mapRef.current);\n        gifOverlayRef.current = overlay;\n\n        // Ajuster la vue de la carte sur la zone du GIF\n        mapRef.current.fitBounds(bounds);\n      }\n      setPendingGif(null);\n      console.log(\"GIF superposé avec succès\");\n    };\n    img.onerror = () => {\n      console.error('Erreur de chargement de l\\'image');\n      setPendingGif(null);\n    };\n    img.src = pendingGif;\n  };\n\n  // Fonction pour récupérer les titres des rapports\n  const fetchRapportTitres = async () => {\n    try {\n      const response = await axios.get(`${API_BASE_URL}/rapports`);\n      // Créer un objet avec les id_rapport comme clés et les titres comme valeurs\n      const titres = {};\n      response.data.forEach(rapport => {\n        titres[rapport.id_rapport] = rapport.titre || 'Rapport sans titre';\n      });\n      setRapportTitres(titres);\n      console.log('Titres des rapports récupérés:', titres);\n    } catch (error) {\n      console.error('Erreur lors de la récupération des titres de rapports:', error);\n    }\n  };\n\n  // Ajoute cette fonction avant le useEffect principal\n  const fetchLieux = async () => {\n    try {\n      const response = await axios.get(`${API_BASE_URL}/lieux`);\n      setLieux(response.data);\n    } catch (error) {\n      console.error('Erreur lors de la récupération des lieux:', error);\n    }\n  };\n\n  // Initialiser la carte et charger les données\n  useEffect(() => {\n    // Initialiser la carte uniquement si le container existe et que la carte n'est pas encore initialisée\n    if (!mapRef.current && mapContainerRef.current) {\n      // Utilisation de la couche SHOM Raster Littoral (WMTS)\n      // Documentation : https://data.shom.fr\n      // URL WMTS : https://wxs.ign.fr/essentiels/geoportail/wmts?SERVICE=WMTS&REQUEST=GetCapabilities\n      // Pour la démo, on utilise le proxy du Géoportail (IGN) qui propose la couche SHOM\n      const shomLayer = L.tileLayer('https://wxs.ign.fr/essentiels/geoportail/wmts?layer=GEOGRAPHICALGRIDSYSTEMS.MAPS.SCANLITTORALE&style=normal&tilematrixset=PM&Service=WMTS&Request=GetTile&Version=1.0.0&Format=image/jpeg&TileMatrix={z}&TileCol={x}&TileRow={y}', {\n        attribution: '&copy; <a href=\"https://www.shom.fr/\">SHOM</a> / <a href=\"https://www.ign.fr/\">IGN</a>',\n        maxZoom: 18,\n        tileSize: 256\n      });\n\n      // Couche OpenStreetMap en attendant une clé SHOM/IGN valide\n      const baseLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {\n        attribution: '&copy; OpenStreetMap contributors',\n        maxZoom: 18\n      });\n      mapRef.current = L.map(mapContainerRef.current).setView([48.2, -3.5], 8); // Bretagne\n      baseLayer.addTo(mapRef.current);\n\n      // Contrôles de navigation maritime (optionnel)\n      const couchesNavigation = {\n        \"Carte OpenStreetMap\": baseLayer\n      };\n      L.control.layers(couchesNavigation, {}, {\n        position: 'topright',\n        collapsed: false\n      }).addTo(mapRef.current);\n\n      // Ajouter une échelle\n      L.control.scale({\n        metric: true,\n        imperial: false,\n        position: 'bottomleft'\n      }).addTo(mapRef.current);\n    }\n\n    // Effectuer la récupération des données au montage du composant\n    fetchLieux();\n    fetchRapportTitres();\n    return () => {\n      // Cleanup de la carte lorsque le composant est démonté\n      if (mapRef.current) {\n        mapRef.current.remove();\n        mapRef.current = null;\n      }\n    };\n  }, [API_BASE_URL]);\n\n  // Ajouter les marqueurs une fois que les lieux et les titres des rapports sont disponibles\n  useEffect(() => {\n    if (mapRef.current && lieux.length > 0) {\n      // Supprimer uniquement les anciens marqueurs\n      markerRefs.current.forEach(marker => {\n        mapRef.current.removeLayer(marker);\n      });\n      markerRefs.current = [];\n\n      // Créer un dictionnaire pour regrouper les lieux par coordonnées\n      const coordsMap = {};\n      lieux.forEach(lieu => {\n        const coordKey = `${lieu.latitude},${lieu.longitude}`;\n        if (!coordsMap[coordKey]) {\n          coordsMap[coordKey] = [];\n        }\n        coordsMap[coordKey].push(lieu);\n      });\n\n      // Ajouter un marqueur pour chaque coordonnée unique\n      Object.entries(coordsMap).forEach(([coords, lieuxAtCoord]) => {\n        const [lat, lng] = coords.split(',');\n\n        // Ne pas ajouter de marqueur si les coordonnées sont invalides\n        if (isNaN(parseFloat(lat)) || isNaN(parseFloat(lng))) {\n          console.warn('Coordonnées invalides:', coords);\n          return;\n        }\n\n        // Utiliser une icône de navigation maritime conforme à la signalisation\n        const iconeNavigation = L.divIcon({\n          className: 'marqueur-navigation-maritime',\n          html: `<div style=\"\n            background: linear-gradient(45deg, #ffffff, #e3f2fd);\n            border: 3px solid #1565c0;\n            border-radius: 50%;\n            width: 26px;\n            height: 26px;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            box-shadow: 0 3px 8px rgba(21,101,192,0.4);\n            font-size: 14px;\n            font-weight: bold;\n            color: #1565c0;\n          \">⚓</div>`,\n          iconSize: [30, 30],\n          iconAnchor: [15, 15]\n        });\n        const marker = L.marker([parseFloat(lat), parseFloat(lng)], {\n          icon: iconeNavigation\n        }).addTo(mapRef.current);\n\n        // Créer le contenu du popup avec informations de navigation maritime\n        let popupContent = `\n          <div>\n            <strong>POSITION DE NAVIGATION</strong>\n            <div>\n              <strong>Coordonnées :</strong>\n              <ul>\n                <li>Lat: ${parseFloat(lat).toFixed(4)}°</li>\n                <li>Lon: ${parseFloat(lng).toFixed(4)}°</li>\n              </ul>\n            </div>\n            <div>\n              <strong>Points d'intérêt maritime :</strong>\n              <ul>\n                ${lieuxAtCoord.map(lieu => `\n                  <li>\n                    ${lieu.details_lieu || 'Position non définie'}<br/>\n                    Rapport: ${rapportTitres[lieu.id_rapport] || `Réf. ${lieu.id_rapport}`}<br/>\n                    ID: ${lieu.id_lieu}<br/>\n                    <button onclick=\"window.location.href='/rapport/${lieu.id_rapport}'\" style=\"margin-top:4px;padding:2px 8px;font-size:13px;cursor:pointer;\">\n                      Visualiser le rapport\n                    </button>\n                  </li>\n                `).join('')}\n              </ul>\n            </div>\n          </div>\n        `;\n        marker.bindPopup(popupContent);\n\n        // Ouvrir le popup si c'est le point actuel\n        if (pointActuel && lieuxAtCoord.some(lieu => lieu.id_lieu === pointActuel.id_lieu)) {\n          marker.openPopup();\n        }\n        markerRefs.current.push(marker); // Stocker le marqueur pour le nettoyage futur\n      });\n    }\n  }, [lieux, rapportTitres, pointActuel]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"page-carte\",\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"carte-header\",\n      children: /*#__PURE__*/_jsxDEV(\"h2\", {\n        children: \"Carte Marine \"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 435,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 434,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"input\", {\n      type: \"file\",\n      accept: \"image/gif\",\n      onChange: handleGifUpload,\n      style: {\n        margin: '1em 0'\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 437,\n      columnNumber: 7\n    }, this), isParsing && /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        marginBottom: '1em',\n        color: '#1565c0',\n        fontWeight: 'bold'\n      },\n      children: \"\\uD83D\\uDD0D Analyse du quadrillage de la carte en cours...\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 446,\n      columnNumber: 9\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        marginBottom: '1em',\n        minHeight: 24\n      },\n      children: [/*#__PURE__*/_jsxDEV(\"label\", {\n        children: [\"Coin Nord-Ouest (Haut gauche)\\xA0\", /*#__PURE__*/_jsxDEV(\"input\", {\n          type: \"text\",\n          value: parsedCoords.hautGauche ? `${parsedCoords.hautGauche.lat}°, ${parsedCoords.hautGauche.lng}°` : \"\",\n          readOnly: true,\n          style: {\n            width: 200,\n            marginRight: 10,\n            background: \"#e8f5e8\",\n            fontFamily: \"monospace\"\n          },\n          placeholder: \"Lat\\xB0, Lng\\xB0\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 455,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 453,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"label\", {\n        children: [\"Coin Sud-Est (Bas droite)\\xA0\", /*#__PURE__*/_jsxDEV(\"input\", {\n          type: \"text\",\n          value: parsedCoords.basDroite ? `${parsedCoords.basDroite.lat}°, ${parsedCoords.basDroite.lng}°` : \"\",\n          readOnly: true,\n          style: {\n            width: 200,\n            background: \"#e8f5e8\",\n            fontFamily: \"monospace\"\n          },\n          placeholder: \"Lat\\xB0, Lng\\xB0\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 465,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 463,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 452,\n      columnNumber: 7\n    }, this), pendingGif && /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        margin: '1em 0',\n        padding: '10px',\n        background: '#f0f8ff',\n        border: '1px solid #1565c0',\n        borderRadius: '4px'\n      },\n      children: [/*#__PURE__*/_jsxDEV(\"span\", {\n        children: \"\\uD83D\\uDCCD GIF analys\\xE9 et pr\\xEAt \\xE0 \\xEAtre superpos\\xE9 sur la carte selon son quadrillage g\\xE9ographique.\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 477,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: handleValidateGif,\n        style: {\n          marginLeft: 10,\n          padding: '5px 15px',\n          background: '#1565c0',\n          color: 'white',\n          border: 'none',\n          borderRadius: '4px',\n          cursor: 'pointer'\n        },\n        children: \"\\uD83D\\uDCCC Superposer sur la carte\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 478,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 476,\n      columnNumber: 9\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      ref: mapContainerRef,\n      className: \"map-container\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 494,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 433,\n    columnNumber: 5\n  }, this);\n};\n_s(Carte, \"2CVgp/q2ZlJGDIZMbdHMlwhbnd4=\");\n_c = Carte;\nexport default Carte;\nvar _c;\n$RefreshReg$(_c, \"Carte\");","map":{"version":3,"names":["useState","useEffect","useRef","axios","L","React","Tesseract","jsxDEV","_jsxDEV","Icon","Default","prototype","_getIconUrl","mergeOptions","iconRetinaUrl","iconUrl","shadowUrl","Carte","_s","lieux","setLieux","rapportTitres","setRapportTitres","mapRef","mapContainerRef","pointActuel","setPointActuel","markerRefs","gifOverlayRef","pendingGif","setPendingGif","parsedCoords","setParsedCoords","hautGauche","lat","lng","basDroite","isParsing","setIsParsing","API_BASE_URL","process","env","REACT_APP_API_URL","dmsToDecimal","degreesStr","minutesStr","direction","degrees","parseInt","replace","minutes","parseFloat","decimal","parseGifForGridCoords","gifDataUrl","Promise","resolve","img","document","createElement","src","onload","canvas","width","height","ctx","getContext","drawImage","imageData","getImageData","data","i","length","avg","contrast","putImageData","processedDataUrl","toDataURL","text","recognize","logger","m","console","log","tessedit_char_whitelist","psm","patterns","latitudes","longitudes","forEach","pattern","match","exec","push","Set","sort","a","b","latMax","Math","max","latMin","min","lngMin","lngMax","warn","error","onerror","handleGifUpload","event","file","target","files","name","endsWith","reader","FileReader","e","result","coords","readAsDataURL","handleValidateGif","current","window","Image","crossOrigin","bounds","removeLayer","overlay","imageOverlay","opacity","interactive","addTo","fitBounds","fetchRapportTitres","response","get","titres","rapport","id_rapport","titre","fetchLieux","shomLayer","tileLayer","attribution","maxZoom","tileSize","baseLayer","map","setView","couchesNavigation","control","layers","position","collapsed","scale","metric","imperial","remove","marker","coordsMap","lieu","coordKey","latitude","longitude","Object","entries","lieuxAtCoord","split","isNaN","iconeNavigation","divIcon","className","html","iconSize","iconAnchor","icon","popupContent","toFixed","details_lieu","id_lieu","join","bindPopup","some","openPopup","children","fileName","_jsxFileName","lineNumber","columnNumber","type","accept","onChange","style","margin","marginBottom","color","fontWeight","minHeight","value","readOnly","marginRight","background","fontFamily","placeholder","padding","border","borderRadius","onClick","marginLeft","cursor","ref","_c","$RefreshReg$"],"sources":["D:/Stage/MarineV3/frontend/src/components/pages/carte.js"],"sourcesContent":["import { useState, useEffect, useRef } from 'react';\r\nimport axios from 'axios';\r\nimport 'leaflet/dist/leaflet.css';\r\nimport L from 'leaflet';\r\nimport '../css/carte.css';\r\nimport React from \"react\";\r\nimport Tesseract from \"tesseract.js\";\r\n\r\n// Fix Leaflet marker icon issue\r\ndelete L.Icon.Default.prototype._getIconUrl;\r\nL.Icon.Default.mergeOptions({\r\n  iconRetinaUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-icon-2x.png',\r\n  iconUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-icon.png',\r\n  shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-shadow.png',\r\n});\r\n\r\nconst Carte = () => {\r\n  const [lieux, setLieux] = useState([]);\r\n  const [rapportTitres, setRapportTitres] = useState({});\r\n  const mapRef = useRef(null);\r\n  const mapContainerRef = useRef(null);\r\n  const [pointActuel, setPointActuel] = useState(null);\r\n  const markerRefs = useRef([]);\r\n  const gifOverlayRef = useRef(null);\r\n  const [pendingGif, setPendingGif] = useState(null);\r\n\r\n  // Ajout pour coordonnées extraites par Tesseract\r\n  const [parsedCoords, setParsedCoords] = useState({ hautGauche: { lat: '', lng: '' }, basDroite: { lat: '', lng: '' } });\r\n  const [isParsing, setIsParsing] = useState(false);\r\n\r\n  const API_BASE_URL = process.env.REACT_APP_API_URL;\r\n\r\n  // Fonction pour convertir DMS en décimal avec support de formats variés\r\n  function dmsToDecimal(degreesStr, minutesStr, direction) {\r\n    // Nettoyer les chaînes en supprimant les caractères parasites\r\n    const degrees = parseInt(degreesStr.replace(/[^\\d]/g, ''), 10);\r\n    const minutes = parseFloat(minutesStr.replace(',', '.').replace(/[^\\d.]/g, ''));\r\n    \r\n    let decimal = degrees + (minutes / 60);\r\n    \r\n    if (direction === 'S' || direction === 'W') {\r\n      decimal *= -1;\r\n    }\r\n    \r\n    return decimal;\r\n  }\r\n\r\n  // Fonction améliorée pour parser les coordonnées du quadrillage\r\n  const parseGifForGridCoords = async (gifDataUrl) => {\r\n    setIsParsing(true);\r\n    return new Promise((resolve) => {\r\n      const img = document.createElement(\"img\");\r\n      img.src = gifDataUrl;\r\n      img.onload = async () => {\r\n        try {\r\n          // Créer un canvas pour traiter l'image\r\n          const canvas = document.createElement(\"canvas\");\r\n          canvas.width = img.width;\r\n          canvas.height = img.height;\r\n          const ctx = canvas.getContext(\"2d\");\r\n          ctx.drawImage(img, 0, 0);\r\n          \r\n          // Préprocessing pour améliorer la reconnaissance\r\n          const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\r\n          const data = imageData.data;\r\n          \r\n          // Augmenter le contraste pour mieux distinguer le texte du quadrillage\r\n          for (let i = 0; i < data.length; i += 4) {\r\n            const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;\r\n            // Améliorer le contraste pour le texte noir sur fond clair\r\n            const contrast = avg < 180 ? 0 : 255;\r\n            data[i] = data[i + 1] = data[i + 2] = contrast;\r\n          }\r\n          \r\n          ctx.putImageData(imageData, 0, 0);\r\n          const processedDataUrl = canvas.toDataURL(\"image/png\");\r\n\r\n          // OCR avec Tesseract avec paramètres optimisés pour les cartes\r\n          const { data: { text } } = await Tesseract.recognize(processedDataUrl, \"eng\", {\r\n            logger: m => console.log(m),\r\n            tessedit_char_whitelist: '0123456789°\\'\\\"NSEW-.,',\r\n            psm: 6, // Uniform block of text\r\n          });\r\n\r\n          console.log(\"Texte extrait:\", text);\r\n\r\n          // Patterns pour différents formats de coordonnées trouvés sur les cartes météo\r\n          const patterns = [\r\n            // Format principal: 49°54'N, 1°36'W (axes de la carte)\r\n            /(\\d+)°(\\d+)'([NS])/g,\r\n            /(\\d+)°(\\d+)'([EW])/g,\r\n            // Format alternatif: 49°54N, 1°36W\r\n            /(\\d+)°(\\d+)([NS])/g,\r\n            /(\\d+)°(\\d+)([EW])/g,\r\n            // Format avec minutes décimales: 49°54.0'N\r\n            /(\\d+)°(\\d+\\.?\\d*)'?([NS])/g,\r\n            /(\\d+)°(\\d+\\.?\\d*)'?([EW])/g,\r\n          ];\r\n\r\n          let latitudes = [];\r\n          let longitudes = [];\r\n\r\n          // Extraire toutes les coordonnées avec tous les patterns\r\n          patterns.forEach(pattern => {\r\n            let match;\r\n            while ((match = pattern.exec(text)) !== null) {\r\n              const degrees = match[1];\r\n              const minutes = match[2] || '0';\r\n              const direction = match[3];\r\n              \r\n              const decimal = dmsToDecimal(degrees, minutes, direction);\r\n              \r\n              if (direction === 'N' || direction === 'S') {\r\n                if (decimal >= -90 && decimal <= 90) { // Validation latitude\r\n                  latitudes.push(decimal);\r\n                }\r\n              } else if (direction === 'E' || direction === 'W') {\r\n                if (decimal >= -180 && decimal <= 180) { // Validation longitude\r\n                  longitudes.push(decimal);\r\n                }\r\n              }\r\n            }\r\n          });\r\n\r\n          // Supprimer les doublons et trier\r\n          latitudes = [...new Set(latitudes)].sort((a, b) => b - a); // Du plus grand au plus petit\r\n          longitudes = [...new Set(longitudes)].sort((a, b) => a - b); // Du plus petit au plus grand\r\n\r\n          console.log(\"Latitudes trouvées:\", latitudes);\r\n          console.log(\"Longitudes trouvées:\", longitudes);\r\n\r\n          // Déterminer les coins de la carte\r\n          let hautGauche = { lat: \"\", lng: \"\" };\r\n          let basDroite = { lat: \"\", lng: \"\" };\r\n\r\n          if (latitudes.length >= 2 && longitudes.length >= 2) {\r\n            // Prendre les extrêmes pour définir le rectangle englobant\r\n            const latMax = Math.max(...latitudes);\r\n            const latMin = Math.min(...latitudes);\r\n            const lngMin = Math.min(...longitudes);\r\n            const lngMax = Math.max(...longitudes);\r\n\r\n            hautGauche = { lat: latMax, lng: lngMin };\r\n            basDroite = { lat: latMin, lng: lngMax };\r\n          } else {\r\n            console.warn(\"Pas assez de coordonnées trouvées pour définir les coins\");\r\n          }\r\n\r\n          setIsParsing(false);\r\n          resolve({ hautGauche, basDroite });\r\n\r\n        } catch (error) {\r\n          console.error(\"Erreur lors du parsing:\", error);\r\n          setIsParsing(false);\r\n          resolve({ hautGauche: { lat: \"\", lng: \"\" }, basDroite: { lat: \"\", lng: \"\" } });\r\n        }\r\n      };\r\n      \r\n      img.onerror = () => {\r\n        console.error(\"Erreur de chargement de l'image\");\r\n        setIsParsing(false);\r\n        resolve({ hautGauche: { lat: \"\", lng: \"\" }, basDroite: { lat: \"\", lng: \"\" } });\r\n      };\r\n    });\r\n  };\r\n\r\n  // Gère la sélection d'un fichier GIF par l'utilisateur\r\n  const handleGifUpload = async (event) => {\r\n    const file = event.target.files[0];\r\n    if (!file || !file.name.endsWith('.gif')) return;\r\n\r\n    const reader = new FileReader();\r\n    reader.onload = async function (e) {\r\n      setPendingGif(e.target.result);\r\n      console.log(\"Début de l'analyse du GIF...\");\r\n      // Appel du parser pour extraire les coordonnées du quadrillage\r\n      const coords = await parseGifForGridCoords(e.target.result);\r\n      console.log(\"Coordonnées extraites:\", coords);\r\n      setParsedCoords(coords);\r\n    };\r\n    reader.readAsDataURL(file);\r\n  };\r\n\r\n  // Valide et superpose le GIF sur la carte Leaflet en utilisant les coordonnées du quadrillage\r\n  const handleValidateGif = () => {\r\n    if (!pendingGif || !mapRef.current) return;\r\n\r\n    const img = new window.Image();\r\n    img.crossOrigin = 'anonymous';\r\n    img.onload = () => {\r\n      // Utiliser les coordonnées extraites du quadrillage\r\n      const hautGauche = parsedCoords.hautGauche;\r\n      const basDroite = parsedCoords.basDroite;\r\n\r\n      // Vérifier que les coordonnées sont valides\r\n      if (!hautGauche.lat || !hautGauche.lng || !basDroite.lat || !basDroite.lng) {\r\n        console.warn(\"Coordonnées du quadrillage non disponibles, utilisation des valeurs par défaut\");\r\n        // Valeurs par défaut pour la zone Bretagne/Manche\r\n        const bounds = [\r\n          [48.5, -5.0], // Sud-Ouest\r\n          [50.5, -1.0]  // Nord-Est\r\n        ];\r\n        \r\n        if (gifOverlayRef.current) {\r\n          mapRef.current.removeLayer(gifOverlayRef.current);\r\n          gifOverlayRef.current = null;\r\n        }\r\n\r\n        const overlay = L.imageOverlay(pendingGif, bounds, {\r\n          opacity: 0.7,\r\n          interactive: false\r\n        });\r\n        overlay.addTo(mapRef.current);\r\n        gifOverlayRef.current = overlay;\r\n      } else {\r\n        // Utiliser les coordonnées extraites du quadrillage\r\n        const bounds = [\r\n          [parseFloat(basDroite.lat), parseFloat(hautGauche.lng)], // Sud-Ouest\r\n          [parseFloat(hautGauche.lat), parseFloat(basDroite.lng)]  // Nord-Est\r\n        ];\r\n\r\n        console.log(\"Bounds calculés:\", bounds);\r\n\r\n        if (gifOverlayRef.current) {\r\n          mapRef.current.removeLayer(gifOverlayRef.current);\r\n          gifOverlayRef.current = null;\r\n        }\r\n\r\n        const overlay = L.imageOverlay(pendingGif, bounds, {\r\n          opacity: 0.7,\r\n          interactive: false\r\n        });\r\n        overlay.addTo(mapRef.current);\r\n        gifOverlayRef.current = overlay;\r\n\r\n        // Ajuster la vue de la carte sur la zone du GIF\r\n        mapRef.current.fitBounds(bounds);\r\n      }\r\n\r\n      setPendingGif(null);\r\n      console.log(\"GIF superposé avec succès\");\r\n    };\r\n\r\n    img.onerror = () => {\r\n      console.error('Erreur de chargement de l\\'image');\r\n      setPendingGif(null);\r\n    };\r\n\r\n    img.src = pendingGif;\r\n  };\r\n\r\n  // Fonction pour récupérer les titres des rapports\r\n  const fetchRapportTitres = async () => {\r\n    try {\r\n      const response = await axios.get(`${API_BASE_URL}/rapports`);\r\n      // Créer un objet avec les id_rapport comme clés et les titres comme valeurs\r\n      const titres = {};\r\n      response.data.forEach(rapport => {\r\n        titres[rapport.id_rapport] = rapport.titre || 'Rapport sans titre';\r\n      });\r\n      setRapportTitres(titres);\r\n      console.log('Titres des rapports récupérés:', titres);\r\n    } catch (error) {\r\n      console.error('Erreur lors de la récupération des titres de rapports:', error);\r\n    }\r\n  };\r\n\r\n  // Ajoute cette fonction avant le useEffect principal\r\n  const fetchLieux = async () => {\r\n    try {\r\n      const response = await axios.get(`${API_BASE_URL}/lieux`);\r\n      setLieux(response.data);\r\n    } catch (error) {\r\n      console.error('Erreur lors de la récupération des lieux:', error);\r\n    }\r\n  };\r\n\r\n  // Initialiser la carte et charger les données\r\n  useEffect(() => {\r\n    // Initialiser la carte uniquement si le container existe et que la carte n'est pas encore initialisée\r\n    if (!mapRef.current && mapContainerRef.current) {\r\n      // Utilisation de la couche SHOM Raster Littoral (WMTS)\r\n      // Documentation : https://data.shom.fr\r\n      // URL WMTS : https://wxs.ign.fr/essentiels/geoportail/wmts?SERVICE=WMTS&REQUEST=GetCapabilities\r\n      // Pour la démo, on utilise le proxy du Géoportail (IGN) qui propose la couche SHOM\r\n      const shomLayer = L.tileLayer(\r\n        'https://wxs.ign.fr/essentiels/geoportail/wmts?layer=GEOGRAPHICALGRIDSYSTEMS.MAPS.SCANLITTORALE&style=normal&tilematrixset=PM&Service=WMTS&Request=GetTile&Version=1.0.0&Format=image/jpeg&TileMatrix={z}&TileCol={x}&TileRow={y}',\r\n        {\r\n          attribution: '&copy; <a href=\"https://www.shom.fr/\">SHOM</a> / <a href=\"https://www.ign.fr/\">IGN</a>',\r\n          maxZoom: 18,\r\n          tileSize: 256,\r\n        }\r\n      );\r\n\r\n      // Couche OpenStreetMap en attendant une clé SHOM/IGN valide\r\n      const baseLayer = L.tileLayer(\r\n        'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',\r\n        {\r\n          attribution: '&copy; OpenStreetMap contributors',\r\n          maxZoom: 18,\r\n        }\r\n      );\r\n\r\n      mapRef.current = L.map(mapContainerRef.current).setView([48.2, -3.5], 8); // Bretagne\r\n      baseLayer.addTo(mapRef.current);\r\n\r\n      // Contrôles de navigation maritime (optionnel)\r\n      const couchesNavigation = {\r\n        \"Carte OpenStreetMap\": baseLayer\r\n      };\r\n\r\n      L.control.layers(couchesNavigation, {}, {\r\n        position: 'topright',\r\n        collapsed: false\r\n      }).addTo(mapRef.current);\r\n\r\n      // Ajouter une échelle\r\n      L.control.scale({\r\n        metric: true,\r\n        imperial: false,\r\n        position: 'bottomleft'\r\n      }).addTo(mapRef.current);\r\n    }\r\n\r\n    // Effectuer la récupération des données au montage du composant\r\n    fetchLieux();\r\n    fetchRapportTitres();\r\n\r\n    return () => {\r\n      // Cleanup de la carte lorsque le composant est démonté\r\n      if (mapRef.current) {\r\n        mapRef.current.remove();\r\n        mapRef.current = null;\r\n      }\r\n    };\r\n  }, [API_BASE_URL]);\r\n\r\n  // Ajouter les marqueurs une fois que les lieux et les titres des rapports sont disponibles\r\n  useEffect(() => {\r\n    if (mapRef.current && lieux.length > 0) {\r\n      // Supprimer uniquement les anciens marqueurs\r\n      markerRefs.current.forEach(marker => {\r\n        mapRef.current.removeLayer(marker);\r\n      });\r\n      markerRefs.current = [];\r\n\r\n      // Créer un dictionnaire pour regrouper les lieux par coordonnées\r\n      const coordsMap = {};\r\n\r\n      lieux.forEach(lieu => {\r\n        const coordKey = `${lieu.latitude},${lieu.longitude}`;\r\n        if (!coordsMap[coordKey]) {\r\n          coordsMap[coordKey] = [];\r\n        }\r\n        coordsMap[coordKey].push(lieu);\r\n      });\r\n\r\n      // Ajouter un marqueur pour chaque coordonnée unique\r\n      Object.entries(coordsMap).forEach(([coords, lieuxAtCoord]) => {\r\n        const [lat, lng] = coords.split(',');\r\n\r\n        // Ne pas ajouter de marqueur si les coordonnées sont invalides\r\n        if (isNaN(parseFloat(lat)) || isNaN(parseFloat(lng))) {\r\n          console.warn('Coordonnées invalides:', coords);\r\n          return;\r\n        }\r\n\r\n        // Utiliser une icône de navigation maritime conforme à la signalisation\r\n        const iconeNavigation = L.divIcon({\r\n          className: 'marqueur-navigation-maritime',\r\n          html: `<div style=\"\r\n            background: linear-gradient(45deg, #ffffff, #e3f2fd);\r\n            border: 3px solid #1565c0;\r\n            border-radius: 50%;\r\n            width: 26px;\r\n            height: 26px;\r\n            display: flex;\r\n            align-items: center;\r\n            justify-content: center;\r\n            box-shadow: 0 3px 8px rgba(21,101,192,0.4);\r\n            font-size: 14px;\r\n            font-weight: bold;\r\n            color: #1565c0;\r\n          \">⚓</div>`,\r\n          iconSize: [30, 30],\r\n          iconAnchor: [15, 15]\r\n        });\r\n\r\n        const marker = L.marker([parseFloat(lat), parseFloat(lng)], { icon: iconeNavigation }).addTo(mapRef.current);\r\n\r\n        // Créer le contenu du popup avec informations de navigation maritime\r\n        let popupContent = `\r\n          <div>\r\n            <strong>POSITION DE NAVIGATION</strong>\r\n            <div>\r\n              <strong>Coordonnées :</strong>\r\n              <ul>\r\n                <li>Lat: ${parseFloat(lat).toFixed(4)}°</li>\r\n                <li>Lon: ${parseFloat(lng).toFixed(4)}°</li>\r\n              </ul>\r\n            </div>\r\n            <div>\r\n              <strong>Points d'intérêt maritime :</strong>\r\n              <ul>\r\n                ${lieuxAtCoord.map(lieu => `\r\n                  <li>\r\n                    ${lieu.details_lieu || 'Position non définie'}<br/>\r\n                    Rapport: ${rapportTitres[lieu.id_rapport] || `Réf. ${lieu.id_rapport}`}<br/>\r\n                    ID: ${lieu.id_lieu}<br/>\r\n                    <button onclick=\"window.location.href='/rapport/${lieu.id_rapport}'\" style=\"margin-top:4px;padding:2px 8px;font-size:13px;cursor:pointer;\">\r\n                      Visualiser le rapport\r\n                    </button>\r\n                  </li>\r\n                `).join('')}\r\n              </ul>\r\n            </div>\r\n          </div>\r\n        `;\r\n\r\n        marker.bindPopup(popupContent);\r\n\r\n        // Ouvrir le popup si c'est le point actuel\r\n        if (pointActuel && lieuxAtCoord.some(lieu => lieu.id_lieu === pointActuel.id_lieu)) {\r\n          marker.openPopup();\r\n        }\r\n\r\n        markerRefs.current.push(marker); // Stocker le marqueur pour le nettoyage futur\r\n      });\r\n    }\r\n  }, [lieux, rapportTitres, pointActuel]);\r\n\r\n  return (\r\n    <div className=\"page-carte\">\r\n      <div className=\"carte-header\">\r\n        <h2>Carte Marine </h2>\r\n      </div>\r\n      <input\r\n        type=\"file\"\r\n        accept=\"image/gif\"\r\n        onChange={handleGifUpload}\r\n        style={{ margin: '1em 0' }}\r\n      />\r\n\r\n      {/* Affichage du chargement */}\r\n      {isParsing && (\r\n        <div style={{ marginBottom: '1em', color: '#1565c0', fontWeight: 'bold' }}>\r\n          🔍 Analyse du quadrillage de la carte en cours...\r\n        </div>\r\n      )}\r\n\r\n      {/* Affichage des coordonnées extraites du quadrillage */}\r\n      <div style={{ marginBottom: '1em', minHeight: 24 }}>\r\n        <label>\r\n          Coin Nord-Ouest (Haut gauche)&nbsp;\r\n          <input\r\n            type=\"text\"\r\n            value={parsedCoords.hautGauche ? `${parsedCoords.hautGauche.lat}°, ${parsedCoords.hautGauche.lng}°` : \"\"}\r\n            readOnly\r\n            style={{ width: 200, marginRight: 10, background: \"#e8f5e8\", fontFamily: \"monospace\" }}\r\n            placeholder=\"Lat°, Lng°\"\r\n          />\r\n        </label>\r\n        <label>\r\n          Coin Sud-Est (Bas droite)&nbsp;\r\n          <input\r\n            type=\"text\"\r\n            value={parsedCoords.basDroite ? `${parsedCoords.basDroite.lat}°, ${parsedCoords.basDroite.lng}°` : \"\"}\r\n            readOnly\r\n            style={{ width: 200, background: \"#e8f5e8\", fontFamily: \"monospace\" }}\r\n            placeholder=\"Lat°, Lng°\"\r\n          />\r\n        </label>\r\n      </div>\r\n\r\n      {pendingGif && (\r\n        <div style={{ margin: '1em 0', padding: '10px', background: '#f0f8ff', border: '1px solid #1565c0', borderRadius: '4px' }}>\r\n          <span>📍 GIF analysé et prêt à être superposé sur la carte selon son quadrillage géographique.</span>\r\n          <button \r\n            onClick={handleValidateGif} \r\n            style={{ \r\n              marginLeft: 10, \r\n              padding: '5px 15px', \r\n              background: '#1565c0', \r\n              color: 'white', \r\n              border: 'none', \r\n              borderRadius: '4px',\r\n              cursor: 'pointer'\r\n            }}\r\n          >\r\n            📌 Superposer sur la carte\r\n          </button>\r\n        </div>\r\n      )}\r\n      <div\r\n        ref={mapContainerRef}\r\n        className=\"map-container\"\r\n      />\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Carte;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}